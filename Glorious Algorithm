=ArrayFormula(Let(
overall_comment,"This cell uses a quadratic factorization method (designed by me, JakkobMath, after I read a bunch of factorization algorithm literature) to completely factor large numbers (inputted into whatever cell you place on the line below). Some small amount of effort has been put into optimizing it, but it could probably be improved by e.g. using better algorithms for finding modular inverses and quadratic residue testing than 'just search the whole range of options and look for matches' and tuning constants. The magic constants and formulas here are vaguely meant to scale in a very loosely correct-feeling way and to more or less match the constants I use for running this algorithm by hand. The target range of numbers to factor is 10000-235959 (the possible outputs of a clock including seconds), but it should work with many larger values and all (positive, integer) smaller ones. Except one. One would be given the empty product as its factorization if it didn't throw an error instead, or if I could be bothered to fix said error.",
n,E3,
primes_up_to,Lambda(bound,Let(
wheel_comment,"Pritchard's sieve. Wheels are column vectors.",
get_wheel_to, Lambda(wheel_bound,Let(
get_next_wheel, Lambda(wheel_in,Let(
prime_to_add, Min(Filter(wheel_in,wheel_in>1)),
wheel_size, Max(wheel_in)+1,
unfiltered_next_wheel,Flatten(Transpose(wheel_in)+Sequence(prime_to_add,1,0,wheel_size)),
Filter(unfiltered_next_wheel, Not(Mod(unfiltered_next_wheel,prime_to_add)=0)))),
get_wheel_to_,Lambda(self,working_bound,working_wheel,
If(Max(working_wheel)+1>=working_bound,working_wheel,
self(self,working_bound,get_next_wheel(working_wheel)))),
get_wheel_to_(get_wheel_to_,wheel_bound,Flatten({1,5})))),
get_primes_section,Lambda(prime_section_bound,Let(
sufficient_wheel,get_wheel_to(prime_section_bound),
section_to_filter,filter(sufficient_wheel,ByRow(sufficient_wheel,Lambda(value,And(value>1,value<=prime_section_bound)))),
max_value,Max(section_to_filter),
divisors_to_remove, Filter(section_to_filter,section_to_filter <= Sqrt(max_vlue)),
products_to_delete, divisors_to_remove*Transpose(divisors_to_remove),
filter(section_to_filter,ByRow(section_to_filter,Lambda(tested_value,CountIf(products_to_delete,tested_value)=0))))),
get_primes_to_,Lambda(self,working_bound,If(working_bound<5,Flatten({2,3}),Let(
top_section,get_primes_section(working_bound),
lowest_prime,Min(top_section),
Flatten(self(self,lowest_prime-1),top_section)))),
get_primes_to_(get_primes_to_,bound))),
trial_divide_list,Lambda(n_in,primes_list,Let(
division_comment,"This function runs through a list of primes to see whether the input is divisible by any of them.",
trial_divide_list_,Lambda(self,working_n_in,working_primes_list,i,If(i>Count(working_primes_list),"Stop",
Let(p,Index(working_primes_list,i,1),
If(Mod(working_n_in,p)=0,p,
self(self,working_n_in,working_primes_list,i+1))))),
trial_divide_list_(trial_divide_list_,n_in,primes_list,1))),
is_residue_small,Lambda(k,q,Let(
residues_list,ArrayFormula(Mod(Sequence(q,1,0,1)^2,q)),
CountIf(residues_list,Mod(k,q))>0)),
get_inverse_small,Lambda(k,q,Index(Filter(Sequence(q-1,1,1,1),Mod(Sequence(q-1,1,k,k),q)=1),1,1)),
get_filter_values,Lambda(n_in,filter_primes,Let(
filter_comment,"We want to decide what prime powers to use for the sieve on a.",
residue_number,Sum(ByRow(filter_primes,Lambda(p,If(p=2,If(is_residue_small(n_in,8),1,0),If(is_residue_small(n_in,p),1,0))))),
effect_bound_comment,"We'll try to use larger factors for bigger n, but we won't use large factors if they don't help us rule out classes.",
effect_bound,Sqrt(residue_number)/(ln(n_in)),
twos_comment,"We don't ever gain from increasing to an odd power for most primes. Two is, of course, the exception: odd powers are better for 2.",
ByRow(filter_primes,Lambda(p,If(p=2,If(is_residue_small(n_in,8),2^Max(3,1-2*Round(ln(effect_bound/2)/(2*ln(2)))),4),If(is_residue_small(n_in,p),p^Max(1,2*Round(-ln(effect_bound)/(2*ln(p)))),p)))))),
get_a_residue_classes,Lambda(n_in,powers_list,Let(
residue_comment,"For a^2-n=b^2 to have solutions, a^2-n must be a quadratic residue mod all prime powers. Hence we only need to check certain classes for a with a quadratic factoring algorithm.",
get_classes_,Lambda(self,working_powers_list,working_modulus,working_classes,i,If(i>Count(working_powers_list),working_classes,
Let(q,Index(working_powers_list,i,1),
inv,get_inverse_small(working_modulus,q),
allowable_q_residues,Filter(Sequence(q,1,0,1),ByRow(Sequence(q,1,0,1),Lambda(k,is_residue_small(k^2-n_in,If(Mod(q,2)=0,2*q,q))))),
combined_residues,Flatten(Mod(working_classes+(Transpose(allowable_q_residues)-working_classes)*working_modulus*inv,working_modulus*q)),
self(self,working_powers_list,working_modulus*q,combined_residues,i+1)))),
Sort(get_classes_(get_classes_,powers_list,1,Flatten({0}),1)))),
factor_once,Lambda(n_in,lower_factor_bound,upper_factor_bound,If(Or(lower_factor_bound>Sqrt(n_in),upper_factor_bound<lower_factor_bound),"Prime",Let(
initial_trial_division_bound,Max(13,Ceiling(Sqrt(n_in)/(3*ln(n_in)/2)+7)),
early_trial_primes, primes_up_to(initial_trial_division_bound),
initial_trial_division_results,trial_divide_list(n_in,early_trial_primes),
If(Not(initial_trial_division_results="Stop"),Flatten(initial_trial_division_results,initial_trial_division_results,upper_factor_bound),
Let(filter_bound,Max(5,Ceiling(3*ln(n_in)/4-2)),
filter_primes,primes_up_to(filter_bound),
filter_values,get_filter_values(n_in,filter_primes),
allowable_a_residues,get_a_residue_classes(n_in,filter_values),
modulus,Product(filter_values),
num_classes,Count(allowable_a_residues),
late_trial_division_bound,Max(31,Ceiling(Sqrt(n_in)/(2*ln(n_in)/3)+3)),
quadratic_cycle_,Lambda(self,i,offset,stop_num,Let(
curr_class,Index(allowable_a_residues,i,1),
a,curr_class+offset,
b,If(a^2<n,0.5,Sqrt(a^2-n_in)),
If(And(Mod(b,1)=0,a-b>1),a-b,
If(a-b<stop_num,"Stop",
self(self,Mod(i,num_classes)+1,If(i=num_classes,modulus,0)+offset,stop_num))))),
quadratic_cycle_results,quadratic_cycle_(quadratic_cycle_,1,0,late_trial_division_bound+2),
If(Not(quadratic_cycle_results="Stop"),Flatten(quadratic_cycle_results,initial_trial_division_bound,quadratic_cycle_results),Let(
longer_trial_primes_list, primes_up_to(late_trial_division_bound),
late_trial_primes,Filter(longer_trial_primes_list,longer_trial_primes_list>initial_trial_division_bound),
late_trial_division_results,trial_divide_list(n_in,late_trial_primes),
If(Not(late_trial_division_results="Stop"),Flatten(late_trial_division_results,late_trial_division_results,late_trial_division_bound),"Prime")))))))),
full_factor_,Lambda(self,n_in,working_lower,working_upper,Let(
factor_once_results,factor_once(n_in,working_lower,working_upper),
found_factor,Index(factor_once_results,1,1),
If(found_factor="Prime",n_in,Let(
new_low_bound,Max(working_lower,Index(factor_once_results,2,1)),
new_high_bound,Min(working_upper,Index(factor_once_results,3,1)),
factorization,Flatten(self(self,found_factor,new_low_bound,new_high_bound),self(self,n_in/found_factor,new_low_bound,new_high_bound)),
Sort(Filter(factorization,factorization>1)))))),
full_factor,Lambda(n_in,full_factor_(full_factor_,n_in,1,Sqrt(n_in))),
full_factor(n)))
